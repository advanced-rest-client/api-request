/* eslint-disable no-plusplus */
/* eslint-disable class-methods-use-this */
import { html, LitElement } from 'lit-element';
import '@advanced-rest-client/authorization/authorization-method.js';
import elementStyles from '../styles/AuthorizationEditor.js';
import '../../api-authorization-method.js';

/** @typedef {import('lit-element').TemplateResult} TemplateResult */
/** @typedef {import('@api-components/amf-helper-mixin').DomainElement} DomainElement */
/** @typedef {import('@api-components/amf-helper-mixin').ApiSecurityRequirement} ApiSecurityRequirement */
/** @typedef {import('@api-components/amf-helper-mixin').ApiParametrizedSecurityScheme} ApiParametrizedSecurityScheme */
/** @typedef {import('@api-components/amf-helper-mixin').ApiSecurityScheme} ApiSecurityScheme */
/** @typedef {import('@api-components/amf-helper-mixin').ApiSecurityHttpSettings} ApiSecurityHttpSettings */
/** @typedef {import('./ApiAuthorizationMethodElement').default} ApiAuthorizationMethodElement */
/** @typedef {import('@advanced-rest-client/arc-types').ArcRequest.RequestAuthorization} RequestAuthorization */
/** @typedef {import('@advanced-rest-client/authorization').Oauth2Credentials} Oauth2Credentials */

/** 
 * @typedef SecurityMethods
 * @property {string[]} types
 * @property {ApiParametrizedSecurityScheme[]} schemes
 */

export const querySecurity = Symbol('querySecurity');
export const securityValue = Symbol('securityValue');
export const processModel = Symbol('processModel');
export const methodsValue = Symbol('methodsValue');
export const computeMethods = Symbol('computeMethods');
export const listSchemeLabels = Symbol('listSchemeLabels');
export const methodTemplate = Symbol('methodTemplate');
export const apiKeyTemplate = Symbol('apiKeyTemplate');
export const oa2AuthTemplate = Symbol('oa2AuthTemplate');
export const oa1AuthTemplate = Symbol('oa1AuthTemplate');
export const bearerAuthTemplate = Symbol('bearerAuthTemplate');
export const basicAuthTemplate = Symbol('basicAuthTemplate');
export const digestAuthTemplate = Symbol('digestAuthTemplate');
export const passThroughAuthTemplate = Symbol('passThroughAuthTemplate');
export const ramlCustomAuthTemplate = Symbol('ramlCustomAuthTemplate');
export const methodTitleTemplate = Symbol('methodTitleTemplate');
export const changeHandler = Symbol('changeHandler');
export const createSettings = Symbol('createSettings');

export default class ApiAuthorizationEditorElement extends LitElement {
  get styles() {
    return elementStyles;
  }

  /**
   * @returns {ApiSecurityRequirement}
   */
  get security() {
    return this[securityValue];
  }

  /**
   * @param {ApiSecurityRequirement} value
   */
  set security(value) {
    const old = this[securityValue];
    if (old === value) {
      return;
    }
    this[securityValue] = value;
    this[processModel]();
    this.requestUpdate();
  }

  static get properties() {
    return {
      /** 
       * The AMF graph model of the API.
       */
      amf: { type: Object },
      // Current HTTP method. Passed by digest method.
      httpMethod: { type: String },
      // Current request URL. Passed by digest method.
      requestUrl: { type: String },
      // Current request body. Passed by digest method.
      requestBody: { type: String },
      /**
       * Whether or not the element is invalid. The validation state changes
       * when settings change or when the `validate()` function is called.
       */
      invalid: { type: Boolean, reflect: true },
      /**
       * List of credentials source
       */
      credentialsSource: { type: Array },
      /**
       * Redirect URL for the OAuth2 authorization.
       */
      oauth2RedirectUri: { type: String },
      /** 
       * When set it overrides the `authorizationUri` in the authorization editor,
       * regardless to the authorization scheme applied to the request.
       * This is to be used with the mocking service.
       */
      oauth2AuthorizationUri: { type: String },
      /** 
       * When set it overrides the `authorizationUri` in the authorization editor,
       * regardless to the authorization scheme applied to the request.
       * This is to be used with the mocking service.
       */
      oauth2AccessTokenUri: { type: String },
      /** 
       * Enabled compatibility with the Anypoint platform.
       */
      compatibility: { type: Boolean, reflect: true },
      /** 
       * Enabled Material Design outlined theme
       */
      outlined: { type: Boolean, reflect: true },
      /**
       * By default the element stores user input in a map that is associated with the specific
       * instance of this element. This way the element can be used multiple times in the same document.
       * However, this way parameter values generated by the generators or entered by the user won't
       * get populated in different operations.
       *
       * By setting this value the element prefers a global cache for values. Once the user enter
       * a value it is registered in the global cache and restored when the same parameter is used again.
       *
       * Do not use this option when the element is embedded multiple times in the page. It will result
       * in generating request data from the cache and not what's in the form inputs and these may not be in sync.
       *
       * These values are stored in memory only. Listen to the `change` event to learn that something changed.
       */
      globalCache: { type: Boolean, reflect: true },
    };
  }

  constructor() {
    super();
    /** @type {DomainElement} */
    this.amf = undefined;
    /** @type {ApiSecurityRequirement} */
    this[securityValue] = undefined;
    /** @type string */
    this.oauth2RedirectUri = undefined;
    /** @type string */
    this.oauth2AuthorizationUri = undefined;
    /** @type string */
    this.oauth2AccessTokenUri = undefined;
    /** @type string */
    this.httpMethod = undefined;
    /** @type string */
    this.requestUrl = undefined;
    /** @type string */
    this.requestBody = undefined;
    /** @type Oauth2Credentials[] */
    this.credentialsSource = undefined;
    /** @type boolean */
    this.compatibility = undefined;
    /** @type boolean */
    this.outlined = undefined;
    /** @type {boolean} */
    this.globalCache = undefined;
    /** @type {SecurityMethods} */
    this[methodsValue] = undefined;
  }

  /**
   * Reads list of authorization methods from the model.
   */
  [processModel]() {
    const security = /** @type {ApiSecurityRequirement} */ (this[securityValue]);
    if (!security) {
      return;
    }
    this[methodsValue] = this[computeMethods](security.schemes);
  }

  /**
   * Computes list of security schemes that can be applied to the element.
   *
   * @param {ApiParametrizedSecurityScheme[]} schemes A list of security schemes to process.
   * @returns {SecurityMethods} A list of authorization methods that can be applied to
   * the current endpoint. Each object describes the list of security types
   * that can be applied to the editor. In OAS an auth method may be an union
   * of methods.
   */
  [computeMethods](schemes) {
    const result = {
      types: [],
      schemes: [],
    };
    schemes.forEach((security) => {
      const type = this[listSchemeLabels](security);
      if (!type) {
        return;
      }
      result.types.push(type);
      result.schemes.push(security);
    });
    return result;
  }

  /**
   * Reads authorization scheme's name and type from the AMF model.
   * @param {ApiParametrizedSecurityScheme} security
   * @return {string|undefined}
   */
  [listSchemeLabels](security) {
    const { name, scheme } = security;
    if (name === 'null') {
      // RAML allows to define a "null" scheme. This means that the authorization
      // for this endpoint is optional.
      return 'No authorization';
    }
    if (!scheme) {
      return undefined;
    }
    let { type } = scheme;
    if (type === 'http') {
      // HTTP type can be `basic` or `bearer`.
      const config = /** @type ApiSecurityHttpSettings */ (scheme.settings);
      if (!config) {
        // this happens when AMF doesn't properly read graph model back to the store.
        // AMF team promised to fix this...
        type = undefined;
      } else {
        type = config.scheme;
      }
    }
    return type;
  }

  /**
   * A function called each time anything change in the editor.
   * Revalidates the component and dispatches the `change` event.
   */
  [changeHandler]() {
    this.validate();
    this.dispatchEvent(new CustomEvent('change'));
  }

  /**
   * Validates state of the editor. It sets `invalid` property when called.
   *
   * Exception: OAuth 2 form reports valid even when the `accessToken` is not
   * set. This adjust for this and reports invalid when `accessToken` for OAuth 2
   * is missing.
   *
   * @return {Boolean} True when the form has valid data.
   */
  validate() {
    const nodes = this.shadowRoot.querySelectorAll('api-authorization-method');
    let valid = true;
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = /** @type ApiAuthorizationMethodElement */(nodes[i]);
      const methodValid = node.validate();
      if (!methodValid) {
        valid = methodValid;
        break;
      } else if (node.type === 'oauth 2' && !node.accessToken) {
        valid = false;
        break;
      }
    }
    this.invalid = !valid;
    return valid;
  }

  /**
   * Creates a list of configuration by calling the `serialize()` function on each
   * currently rendered authorization form.
   *
   * @return {RequestAuthorization[]} List of authorization settings.
   */
  serialize() {
    const nodes = this.shadowRoot.querySelectorAll('api-authorization-method');
    const result = [];
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = /** @type ApiAuthorizationMethodElement */(nodes[i]);
      result.push(this[createSettings](node));
    }
    return result;
  }

  /**
   * Creates an authorization settings object for passed authorization panel.
   * @param {ApiAuthorizationMethodElement} target api-authorization-method instance
   * @return {RequestAuthorization}
   */
  [createSettings](target) {
    const config = target.serialize();
    let valid = target.validate();
    const { type } = target;
    if (type === 'oauth 2' && !config.accessToken) {
      valid = false;
    }
    return {
      type,
      valid,
      config,
      enabled: true,
    };
  }

  /**
   * Calls the `authorize()` function on each rendered authorization methods.
   * Currently only `OAuth 1.0` and `OAuth 2.0` actually perform the authorization. 
   * 
   * Each method is called in order to make sure the user is not overwhelmed with 
   * dialogs or other UI elements.
   * 
   * The function rejects when at least one authorization method rejects.
   */
  async authorize() {
    const nodes = this.shadowRoot.querySelectorAll('api-authorization-method');
    const list = Array.from(nodes);
    while (list.length) {
      const auth = list.shift();
      // eslint-disable-next-line no-await-in-loop
      await auth.authorize();
    }
  }

  render() {
    const methods = this[methodsValue];
    if (!methods || !methods.schemes.length) {
      return html``;
    }
    return html`
    <style>${this.styles}</style>
    <section class="authorization-union">
    ${methods.schemes.map((scheme, index) => this[methodTemplate](scheme, methods.types[index]))}
    </section>
    `;
  }

  /**
   * @param {ApiParametrizedSecurityScheme} scheme
   * @param {string} type
   * @return {TemplateResult|string} 
   */
  [methodTemplate](scheme, type) {
    switch (type) {
      case 'Basic Authentication':
      case 'basic':
        return this[basicAuthTemplate](scheme);
      case 'Digest Authentication':
        return this[digestAuthTemplate](scheme, true);
      case 'Pass Through':
        return this[passThroughAuthTemplate](scheme, true);
      case 'OAuth 2.0':
        return this[oa2AuthTemplate](scheme);
      case 'OAuth 1.0':
        return this[oa1AuthTemplate](scheme, true);
      case 'bearer':
        return this[bearerAuthTemplate](scheme, true);
      case 'Api Key':
        return this[apiKeyTemplate](scheme);
      default:
        if (String(type).indexOf('x-') === 0) {
          return this[ramlCustomAuthTemplate](scheme);
        }
    }
    return '';
  }

  /**
   * Renders title to be rendered above authorization method
   * @param {ApiParametrizedSecurityScheme} scheme Authorization scheme to be applied to the method
   * @return {TemplateResult|string}
   */
  [methodTitleTemplate](scheme) {
    const { name } = scheme;
    if (!name) {
      return '';
    }
    return html`<div class="auth-label">${name}</div>`;
  }

  /**
   * Renders a template for Basic authorization.
   *
   * @param {ApiParametrizedSecurityScheme} security Security scheme
   * @return {TemplateResult}
   */
  [basicAuthTemplate](security) {
    const { compatibility, outlined, amf, globalCache } = this;
    return html`
    ${this[methodTitleTemplate](security)}
    <api-authorization-method
      .amf="${amf}"
      ?compatibility="${compatibility}"
      ?outlined="${outlined}"
      ?globalCache="${globalCache}"
      type="basic"
      @change="${this[changeHandler]}"
    ></api-authorization-method>`;
  }

  /**
   * Renders a template for Digest authorization.
   *
   * @param {ApiParametrizedSecurityScheme} security Security scheme
   * @param {boolean=} renderTitle
   * @return {TemplateResult}
   */
  [digestAuthTemplate](security, renderTitle) {
    const {
      compatibility,
      outlined,
      httpMethod,
      requestUrl,
      requestBody,
      amf,
      globalCache,
    } = this;
    return html`
    ${renderTitle ? this[methodTitleTemplate](security) : ''}
    <api-authorization-method
      ?compatibility="${compatibility}"
      ?outlined="${outlined}"
      ?globalCache="${globalCache}"
      .amf="${amf}"
      .httpMethod="${httpMethod}"
      .requestUrl="${requestUrl}"
      .requestBody="${requestBody}"
      type="digest"
      @change="${this[changeHandler]}"
    ></api-authorization-method>`;
  }

  /**
   * Renders a template for Pass through authorization.
   *
   * @param {ApiParametrizedSecurityScheme} security Security scheme
   * @param {boolean=} renderTitle
   * @return {TemplateResult}
   */
  [passThroughAuthTemplate](security, renderTitle) {
    const { compatibility, outlined, amf, globalCache, } = this;
    return html`
    ${renderTitle ? this[methodTitleTemplate](security) : ''}
    <api-authorization-method
      ?compatibility="${compatibility}"
      ?outlined="${outlined}"
      ?globalCache="${globalCache}"
      .amf="${amf}"
      .security="${security}"
      type="pass through"
      @change="${this[changeHandler]}"
    ></api-authorization-method>`;
  }

  /**
   * Renders a template for RAML custom authorization.
   *
   * @param {ApiParametrizedSecurityScheme} security Security scheme
   * @return {TemplateResult}
   */
  [ramlCustomAuthTemplate](security) {
    const { compatibility, outlined, amf, globalCache, } = this;
    return html`<api-authorization-method
      ?compatibility="${compatibility}"
      ?outlined="${outlined}"
      ?globalCache="${globalCache}"
      .amf="${amf}"
      .security="${security}"
      type="custom"
      @change="${this[changeHandler]}"
    ></api-authorization-method>`;
  }

  /**
   * Renders a template for Bearer authorization (OAS).
   *
   * @param {ApiParametrizedSecurityScheme} security Security scheme
   * @param {boolean=} renderTitle
   * @return {TemplateResult}
   */
  [bearerAuthTemplate](security, renderTitle) {
    const { compatibility, outlined, amf, globalCache, } = this;
    return html`
    ${renderTitle ? this[methodTitleTemplate](security) : ''}
    <api-authorization-method
      ?compatibility="${compatibility}"
      ?outlined="${outlined}"
      ?globalCache="${globalCache}"
      type="bearer"
      .amf="${amf}"
      .security="${security}"
      @change="${this[changeHandler]}"
    ></api-authorization-method>`;
  }

  /**
   * Renders a template for OAuth 1 authorization.
   *
   * @param {ApiParametrizedSecurityScheme} security Security scheme
   * @param {boolean=} renderTitle
   * @return {TemplateResult}
   */
  [oa1AuthTemplate](security, renderTitle) {
    const { compatibility, outlined, oauth2RedirectUri, amf, globalCache, } = this;
    return html`
    ${renderTitle ? this[methodTitleTemplate](security) : ''}
    <api-authorization-method
      ?compatibility="${compatibility}"
      ?outlined="${outlined}"
      ?globalCache="${globalCache}"
      type="oauth 1"
      .redirectUri="${oauth2RedirectUri}"
      .amf="${amf}"
      .security="${security}"
      @change="${this[changeHandler]}"
    ></api-authorization-method>`;
  }

  /**
   * Renders a template for OAuth 2 authorization.
   *
   * @param {ApiParametrizedSecurityScheme} security Security scheme
   * @return {TemplateResult}
   */
  [oa2AuthTemplate](security) {
    const {
      compatibility,
      outlined,
      oauth2RedirectUri,
      credentialsSource,
      oauth2AuthorizationUri,
      oauth2AccessTokenUri,
      amf,
      globalCache,
    } = this;
    return html`
    ${this[methodTitleTemplate](security)}
    <api-authorization-method
      ?compatibility="${compatibility}"
      ?outlined="${outlined}"
      ?globalCache="${globalCache}"
      type="oauth 2"
      .redirectUri="${oauth2RedirectUri}"
      .overrideAuthorizationUri="${oauth2AuthorizationUri}"
      .overrideAccessTokenUri="${oauth2AccessTokenUri}"
      .amf="${amf}"
      .security="${security}"
      .credentialsSource="${credentialsSource}"
      @change="${this[changeHandler]}"
    ></api-authorization-method>`;
  }

  /**
   * Renders a template for Api Keys authorization.
   *
   * @param {ApiParametrizedSecurityScheme} security Security scheme
   * @return {TemplateResult}
   */
  [apiKeyTemplate](security) {
    const { compatibility, outlined, amf, globalCache, } = this;
    return html`
    ${this[methodTitleTemplate](security)}
    <api-authorization-method
      ?globalCache="${globalCache}"
      ?compatibility="${compatibility}"
      ?outlined="${outlined}"
      type="api key"
      .amf="${amf}"
      .security="${security}"
      @change="${this[changeHandler]}"
    ></api-authorization-method>
    `;
  }
}
